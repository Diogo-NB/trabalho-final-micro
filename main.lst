CCS PCM C Compiler, Version 5.076, 56587               12-dez-24 23:47

               Filename:   D:\Facu\MICRO\trabalho_final_v2\main.lst

               ROM used:   862 words (21%)
                           Largest free fragment is 2048
               RAM used:   35 (18%) at main() level
                           42 (22%) worst case
               Stack used: 3 locations (2 in main + 1 for interrupts)
               Stack size: 8

*
0000:  MOVLW  02
0001:  MOVWF  0A
0002:  GOTO   259
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  25
0008:  MOVF   7F,W
0009:  MOVWF  24
000A:  MOVF   0A,W
000B:  MOVWF  2B
000C:  CLRF   0A
000D:  SWAPF  24,F
000E:  MOVF   04,W
000F:  MOVWF  26
0010:  MOVF   20,W
0011:  MOVWF  27
0012:  MOVF   21,W
0013:  MOVWF  28
0014:  MOVF   22,W
0015:  MOVWF  29
0016:  MOVF   23,W
0017:  MOVWF  2A
0018:  BCF    03.7
0019:  BCF    03.5
001A:  BTFSS  0B.5
001B:  GOTO   01E
001C:  BTFSC  0B.2
001D:  GOTO   02F
001E:  MOVF   26,W
001F:  MOVWF  04
0020:  MOVF   27,W
0021:  MOVWF  20
0022:  MOVF   28,W
0023:  MOVWF  21
0024:  MOVF   29,W
0025:  MOVWF  22
0026:  MOVF   2A,W
0027:  MOVWF  23
0028:  MOVF   2B,W
0029:  MOVWF  0A
002A:  SWAPF  25,W
002B:  MOVWF  03
002C:  SWAPF  7F,F
002D:  SWAPF  7F,W
002E:  RETFIE
002F:  BCF    0A.3
0030:  GOTO   09F
.................... #include <main.h> 
.................... #include <16F874A.h> 
.................... //////////// Standard Header file for the PIC16F874A device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F874A 
0031:  BCF    0A.0
0032:  BCF    0A.1
0033:  BCF    0A.2
0034:  ADDWF  02,F
0035:  RETLW  3F
0036:  RETLW  06
0037:  RETLW  5B
0038:  RETLW  4F
0039:  RETLW  66
003A:  RETLW  6D
003B:  RETLW  7D
003C:  RETLW  07
003D:  RETLW  7F
003E:  RETLW  6F
003F:  BCF    0A.0
0040:  BCF    0A.1
0041:  BCF    0A.2
0042:  ADDWF  02,F
0043:  RETLW  02
0044:  RETLW  03
0045:  RETLW  05
0046:  RETLW  07
0047:  RETLW  09
0048:  RETLW  06
0049:  RETLW  08
004A:  RETLW  04
004B:  RETLW  02
004C:  RETLW  03
004D:  RETLW  06
004E:  RETLW  09
004F:  RETLW  07
0050:  RETLW  04
0051:  RETLW  05
0052:  RETLW  08
0053:  RETLW  02
0054:  RETLW  03
0055:  RETLW  07
0056:  RETLW  06
0057:  BCF    0A.0
0058:  BCF    0A.1
0059:  BCF    0A.2
005A:  ADDWF  02,F
005B:  RETLW  04
005C:  RETLW  06
005D:  RETLW  08
005E:  RETLW  09
005F:  RETLW  07
0060:  RETLW  05
0061:  RETLW  03
0062:  RETLW  02
0063:  RETLW  09
0064:  RETLW  06
0065:  RETLW  08
0066:  RETLW  07
0067:  RETLW  03
0068:  RETLW  05
0069:  RETLW  04
006A:  RETLW  09
006B:  RETLW  02
006C:  RETLW  06
006D:  RETLW  08
006E:  RETLW  07
006F:  BCF    0A.0
0070:  BCF    0A.1
0071:  BCF    0A.2
0072:  ADDWF  02,F
0073:  RETLW  09
0074:  RETLW  08
0075:  RETLW  07
0076:  RETLW  06
0077:  RETLW  05
0078:  RETLW  04
0079:  RETLW  03
007A:  RETLW  02
007B:  RETLW  09
007C:  RETLW  08
007D:  RETLW  04
007E:  RETLW  05
007F:  RETLW  07
0080:  RETLW  03
0081:  RETLW  09
0082:  RETLW  06
0083:  RETLW  08
0084:  RETLW  02
0085:  RETLW  05
0086:  RETLW  04
0087:  BCF    0A.0
0088:  BCF    0A.1
0089:  BCF    0A.2
008A:  ADDWF  02,F
008B:  RETLW  03
008C:  RETLW  05
008D:  RETLW  07
008E:  RETLW  02
008F:  RETLW  08
0090:  RETLW  04
0091:  RETLW  06
0092:  RETLW  09
0093:  RETLW  03
0094:  RETLW  07
0095:  RETLW  08
0096:  RETLW  06
0097:  RETLW  02
0098:  RETLW  05
0099:  RETLW  09
009A:  RETLW  04
009B:  RETLW  07
009C:  RETLW  03
009D:  RETLW  06
009E:  RETLW  08
*
00B9:  CLRF   21
00BA:  CLRF   22
00BB:  CLRF   20
00BC:  CLRF   23
00BD:  MOVF   45,W
00BE:  BTFSS  03.2
00BF:  GOTO   0C3
00C0:  MOVF   44,W
00C1:  BTFSC  03.2
00C2:  GOTO   0DD
00C3:  MOVLW  10
00C4:  MOVWF  46
00C5:  BCF    03.0
00C6:  RLF    42,F
00C7:  RLF    43,F
00C8:  RLF    20,F
00C9:  RLF    23,F
00CA:  MOVF   45,W
00CB:  SUBWF  23,W
00CC:  BTFSS  03.2
00CD:  GOTO   0D0
00CE:  MOVF   44,W
00CF:  SUBWF  20,W
00D0:  BTFSS  03.0
00D1:  GOTO   0D9
00D2:  MOVF   44,W
00D3:  SUBWF  20,F
00D4:  BTFSS  03.0
00D5:  DECF   23,F
00D6:  MOVF   45,W
00D7:  SUBWF  23,F
00D8:  BSF    03.0
00D9:  RLF    21,F
00DA:  RLF    22,F
00DB:  DECFSZ 46,F
00DC:  GOTO   0C5
00DD:  RETURN
*
0130:  BSF    0A.0
0131:  BCF    0A.1
0132:  BCF    0A.2
0133:  ADDWF  02,F
0134:  GOTO   0F8
0135:  GOTO   102
0136:  GOTO   10C
0137:  GOTO   116
*
01AC:  BSF    0A.0
01AD:  BCF    0A.1
01AE:  BCF    0A.2
01AF:  ADDWF  02,F
01B0:  GOTO   159
01B1:  GOTO   16C
01B2:  GOTO   17F
01B3:  GOTO   191
*
01C7:  MOVF   43,W
01C8:  ANDLW  07
01C9:  MOVWF  20
01CA:  RRF    43,W
01CB:  MOVWF  21
01CC:  RRF    21,F
01CD:  RRF    21,F
01CE:  MOVLW  1F
01CF:  ANDWF  21,F
01D0:  MOVF   21,W
01D1:  ADDWF  45,W
01D2:  MOVWF  04
01D3:  CLRF   21
01D4:  INCF   21,F
01D5:  INCF   20,F
01D6:  GOTO   1D8
01D7:  RLF    21,F
01D8:  DECFSZ 20,F
01D9:  GOTO   1D7
01DA:  MOVF   44,F
01DB:  BTFSC  03.2
01DC:  GOTO   1E0
01DD:  MOVF   21,W
01DE:  IORWF  00,F
01DF:  GOTO   1E3
01E0:  COMF   21,F
01E1:  MOVF   21,W
01E2:  ANDWF  00,F
01E3:  RETURN
01E4:  MOVF   43,W
01E5:  ANDLW  07
01E6:  MOVWF  20
01E7:  RRF    43,W
01E8:  MOVWF  21
01E9:  RRF    21,F
01EA:  RRF    21,F
01EB:  MOVLW  1F
01EC:  ANDWF  21,F
01ED:  MOVF   21,W
01EE:  ADDWF  44,W
01EF:  MOVWF  04
01F0:  MOVF   00,W
01F1:  MOVWF  21
01F2:  INCF   20,F
01F3:  GOTO   1F5
01F4:  RRF    21,F
01F5:  DECFSZ 20,F
01F6:  GOTO   1F4
01F7:  MOVLW  01
01F8:  ANDWF  21,F
01F9:  BCF    0A.3
01FA:  GOTO   20F (RETURN)
*
0251:  BCF    0A.0
0252:  BSF    0A.1
0253:  BCF    0A.2
0254:  ADDWF  02,F
0255:  GOTO   239
0256:  GOTO   23F
0257:  GOTO   245
0258:  GOTO   24B
....................  
.................... #list 
....................  
.................... #device ADC=10 
....................  
.................... #FUSES PUT                      //Power Up Timer 
.................... #FUSES BROWNOUT                 //Reset when brownout detected 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOCPD                    //No EE protection 
.................... #FUSES NOWRT                    //Program memory not write protected 
.................... #FUSES NOPROTECT                //Code not protected from reading 
....................  
.................... #use delay(crystal=4MHz) 
*
00DE:  MOVLW  41
00DF:  MOVWF  04
00E0:  MOVF   00,W
00E1:  BTFSC  03.2
00E2:  GOTO   0F1
00E3:  MOVLW  01
00E4:  MOVWF  21
00E5:  CLRF   20
00E6:  DECFSZ 20,F
00E7:  GOTO   0E6
00E8:  DECFSZ 21,F
00E9:  GOTO   0E5
00EA:  MOVLW  4A
00EB:  MOVWF  20
00EC:  DECFSZ 20,F
00ED:  GOTO   0EC
00EE:  GOTO   0EF
00EF:  DECFSZ 00,F
00F0:  GOTO   0E3
00F1:  RETURN
....................  
.................... #use FIXED_IO(D_outputs=PIN_D7,PIN_D6,PIN_D5,PIN_D4,PIN_D3,PIN_D2,PIN_D1,PIN_D0) 
.................... #use FIXED_IO(B_outputs=PIN_B7,PIN_B6,PIN_B5,PIN_B4) 
....................  
.................... #define S1   PIN_B0 
.................... #define S2   PIN_B1 
.................... #define S3   PIN_B2 
.................... #define S4   PIN_B3 
....................  
.................... #define DU   PIN_B7 
.................... #define DD   PIN_B6 
.................... #define DC   PIN_B5 
.................... #define DM   PIN_B4 
....................  
....................  
....................  
.................... #define  V_FILTRO 100 
....................  
.................... #define  V_CONTADOR_DISPLAY  1 
....................  
.................... #define  V_CONT_SEQUENCIA_FASE1  333 
.................... #define  V_CONT_SEQUENCIA_FASE2  270 
.................... #define  V_CONT_SEQUENCIA_FASE3  200 
.................... #define  V_CONT_SEQUENCIA_FASE4  150 
....................  
.................... #define  TAM_SEQUENCIA  20 
....................  
.................... int16 v_cont_sequencia; 
....................  
.................... int8 filtro[] = {0, 0, 0, 0}; 
*
026D:  BCF    03.5
026E:  CLRF   2E
026F:  CLRF   2F
0270:  CLRF   30
0271:  CLRF   31
.................... int1 lido[] = {0, 0, 0, 0}; 
0272:  CLRF   32
....................  
.................... int8 contador_display = 0; 
.................... int1 atualiza_display = 0; 
....................  
.................... int16 cont_sequencia = 0; 
.................... int1 atualiza_sequencia = 0; 
....................  
.................... int16 pontos = 0; 
....................  
.................... int8 estado = 0; // Estado do jogo : 0 - menu inicial ; 1 - fase 1 ; 2 - fase 2 ; 3 - fase 3 ; 4 - fase 4 ; 5 - falha 
....................  
.................... int8 d_index = 0; // index dos digitos  
....................  
.................... const int8 display_numbers[] = {0x3F, 0x06, 0x5B, 0x4F, 0x66, 0x6D, 0x7D, 0x07, 0x7F, 0x6F}; 
.................... int8 digitos[] = {0, 0, 0, 0}; 
0273:  CLRF   3B
0274:  CLRF   3C
0275:  CLRF   3D
0276:  CLRF   3E
....................  
.................... const int8 sequencia_fase1[] = {2, 3, 5, 7, 9, 6, 8, 4, 2, 3, 6, 9, 7, 4, 5, 8, 2, 3, 7, 6}; 
.................... const int8 sequencia_fase2[] = {4, 6, 8, 9, 7, 5, 3, 2, 9, 6, 8, 7, 3, 5, 4, 9, 2, 6, 8, 7}; 
.................... const int8 sequencia_fase3[] = {9, 8, 7, 6, 5, 4, 3, 2, 9, 8, 4, 5, 7, 3, 9, 6, 8, 2, 5, 4}; 
.................... const int8 sequencia_fase4[] = {3, 5, 7, 2, 8, 4, 6, 9, 3, 7, 8, 6, 2, 5, 9, 4, 7, 3, 6, 8}; 
....................  
.................... int8 i_sequencia_atual = 0; 
....................  
.................... #INT_TIMER0 
.................... void  TIMER0_isr(void)  
.................... { 
....................    set_timer0(get_timer0() + 6); 
*
009F:  MOVF   01,W
00A0:  ADDLW  06
00A1:  MOVWF  48
00A2:  MOVF   48,W
00A3:  MOVWF  01
....................    contador_display--; 
00A4:  DECFSZ 33,F
....................    if (!contador_display) { // 200ms 
00A5:  GOTO   0A9
....................       contador_display = V_CONTADOR_DISPLAY; 
00A6:  MOVLW  01
00A7:  MOVWF  33
....................       atualiza_display = 1; 
00A8:  BSF    34.0
....................    } 
....................     
....................    cont_sequencia--; 
00A9:  MOVF   35,W
00AA:  BTFSC  03.2
00AB:  DECF   36,F
00AC:  DECF   35,F
....................    if (!cont_sequencia) { 
00AD:  MOVF   35,W
00AE:  IORWF  36,W
00AF:  BTFSS  03.2
00B0:  GOTO   0B6
....................       cont_sequencia = v_cont_sequencia; 
00B1:  MOVF   2D,W
00B2:  MOVWF  36
00B3:  MOVF   2C,W
00B4:  MOVWF  35
....................       atualiza_sequencia = 1; 
00B5:  BSF    34.1
....................    } 
00B6:  BCF    0B.2
00B7:  BCF    0A.3
00B8:  GOTO   01E
.................... } 
....................  
.................... int1 filter_bt_state(int1 state, int8 i); 
....................  
.................... int8 get_prox_valor_sequencia(); 
....................  
.................... void atualiza_displayf(); 
....................  
.................... void atualiza_sequenciaf(); 
....................  
.................... void inicializa_fase(); 
....................  
.................... void escolha_fase(); 
....................  
.................... void main() 
*
0259:  MOVF   03,W
025A:  ANDLW  1F
025B:  MOVWF  03
025C:  CLRF   33
025D:  BCF    34.0
025E:  CLRF   36
025F:  CLRF   35
0260:  BCF    34.1
0261:  CLRF   38
0262:  CLRF   37
0263:  CLRF   39
0264:  CLRF   3A
0265:  CLRF   3F
0266:  BSF    03.5
0267:  BSF    1F.0
0268:  BSF    1F.1
0269:  BSF    1F.2
026A:  BCF    1F.3
026B:  MOVLW  07
026C:  MOVWF  1C
.................... { 
....................    setup_timer_0(RTCC_INTERNAL|RTCC_DIV_16|RTCC_8_BIT); 
*
0277:  BSF    03.5
0278:  MOVF   01,W
0279:  ANDLW  C0
027A:  IORLW  03
027B:  MOVWF  01
....................  
....................    enable_interrupts(INT_TIMER0); 
027C:  BCF    03.5
027D:  BSF    0B.5
....................    enable_interrupts(GLOBAL); 
027E:  MOVLW  C0
027F:  IORWF  0B,F
....................     
....................    while(TRUE) 
....................    { 
....................       output_b(0x0F); 
0280:  MOVLW  0F
0281:  BSF    03.5
0282:  MOVWF  06
0283:  BCF    03.5
0284:  MOVWF  06
....................       output_d(0); 
0285:  BSF    03.5
0286:  CLRF   08
0287:  BCF    03.5
0288:  CLRF   08
....................       output_high(DU); 
0289:  BSF    03.5
028A:  MOVWF  06
028B:  BCF    03.5
028C:  BSF    06.7
....................       i_sequencia_atual = 3; 
028D:  MOVLW  03
028E:  MOVWF  3F
....................        
.................... //!      output_b(0xFF); 
.................... //!      output_d(0); 
.................... //!      output_low(DU); 
....................  
....................       digitos[0] = (pontos / 1000) % 10; 
028F:  MOVF   38,W
0290:  MOVWF  43
0291:  MOVF   37,W
0292:  MOVWF  42
0293:  MOVLW  03
0294:  MOVWF  45
0295:  MOVLW  E8
0296:  MOVWF  44
0297:  CALL   0B9
0298:  MOVF   22,W
0299:  MOVWF  41
029A:  MOVF   21,W
029B:  MOVWF  40
029C:  MOVF   22,W
029D:  MOVWF  43
029E:  MOVF   21,W
029F:  MOVWF  42
02A0:  CLRF   45
02A1:  MOVLW  0A
02A2:  MOVWF  44
02A3:  CALL   0B9
02A4:  MOVF   20,W
02A5:  MOVWF  3B
....................       digitos[1] = (pontos / 100) % 10 ; 
02A6:  MOVF   38,W
02A7:  MOVWF  43
02A8:  MOVF   37,W
02A9:  MOVWF  42
02AA:  CLRF   45
02AB:  MOVLW  64
02AC:  MOVWF  44
02AD:  CALL   0B9
02AE:  MOVF   22,W
02AF:  MOVWF  41
02B0:  MOVF   21,W
02B1:  MOVWF  40
02B2:  MOVF   22,W
02B3:  MOVWF  43
02B4:  MOVF   21,W
02B5:  MOVWF  42
02B6:  CLRF   45
02B7:  MOVLW  0A
02B8:  MOVWF  44
02B9:  CALL   0B9
02BA:  MOVF   20,W
02BB:  MOVWF  3C
....................       digitos[2] = (pontos / 10) % 10; 
02BC:  MOVF   38,W
02BD:  MOVWF  43
02BE:  MOVF   37,W
02BF:  MOVWF  42
02C0:  CLRF   45
02C1:  MOVLW  0A
02C2:  MOVWF  44
02C3:  CALL   0B9
02C4:  MOVF   22,W
02C5:  MOVWF  41
02C6:  MOVF   21,W
02C7:  MOVWF  40
02C8:  MOVF   22,W
02C9:  MOVWF  43
02CA:  MOVF   21,W
02CB:  MOVWF  42
02CC:  CLRF   45
02CD:  MOVLW  0A
02CE:  MOVWF  44
02CF:  CALL   0B9
02D0:  MOVF   20,W
02D1:  MOVWF  3D
....................       digitos[3] = pontos % 10; 
02D2:  MOVF   38,W
02D3:  MOVWF  43
02D4:  MOVF   37,W
02D5:  MOVWF  42
02D6:  CLRF   45
02D7:  MOVLW  0A
02D8:  MOVWF  44
02D9:  CALL   0B9
02DA:  MOVF   20,W
02DB:  MOVWF  3E
....................        
....................       delay_ms(500); 
02DC:  MOVLW  02
02DD:  MOVWF  40
02DE:  MOVLW  FA
02DF:  MOVWF  41
02E0:  CALL   0DE
02E1:  DECFSZ 40,F
02E2:  GOTO   2DE
....................       
....................       while (!estado) { 
02E3:  MOVF   39,F
02E4:  BTFSS  03.2
02E5:  GOTO   2EC
....................          if (atualiza_display) { 
02E6:  BTFSS  34.0
02E7:  GOTO   2EA
....................             atualiza_display = 0; 
02E8:  BCF    34.0
....................             atualiza_displayf(); 
02E9:  CALL   0F2
....................          } 
....................          escolha_fase(); 
02EA:  GOTO   138
02EB:  GOTO   2E3
....................       } 
....................        
....................       delay_ms(100); 
02EC:  MOVLW  64
02ED:  MOVWF  41
02EE:  CALL   0DE
....................        
....................       inicializa_fase(); 
02EF:  GOTO   152
....................        
....................       pontos = 0; 
02F0:  CLRF   38
02F1:  CLRF   37
....................        
....................       while (estado) { 
02F2:  MOVF   39,F
02F3:  BTFSC  03.2
02F4:  GOTO   35C
....................          if (pontos >= 25) { 
02F5:  MOVF   38,F
02F6:  BTFSS  03.2
02F7:  GOTO   2FB
02F8:  MOVF   37,W
02F9:  SUBLW  18
02FA:  BTFSS  03.0
....................             estado = 0; 
02FB:  CLRF   39
....................          } 
....................           
....................          if (atualiza_display) { 
02FC:  BTFSS  34.0
02FD:  GOTO   300
....................             atualiza_display = 0; 
02FE:  BCF    34.0
....................             atualiza_displayf(); 
02FF:  CALL   0F2
....................          } 
....................           
....................          if (atualiza_sequencia) { 
0300:  BTFSS  34.1
0301:  GOTO   304
....................             atualiza_sequencia = 0; 
0302:  BCF    34.1
....................             atualiza_sequenciaf(); 
0303:  GOTO   1B4
....................          } 
....................        
....................          if (filter_bt_state(input_state(S1), 0)) { 
0304:  MOVLW  00
0305:  BTFSC  06.0
0306:  MOVLW  01
0307:  MOVWF  40
0308:  MOVWF  41
0309:  CLRF   42
030A:  CALL   1FB
030B:  MOVF   21,F
030C:  BTFSC  03.2
030D:  GOTO   319
....................             if (!digitos[0]) { 
030E:  MOVF   3B,F
030F:  BTFSS  03.2
0310:  GOTO   318
....................                pontos++; 
0311:  INCF   37,F
0312:  BTFSC  03.2
0313:  INCF   38,F
....................                digitos[0] = get_prox_valor_sequencia();  
0314:  CALL   22D
0315:  MOVF   21,W
0316:  MOVWF  3B
....................             } else { 
0317:  GOTO   319
....................                estado = 0; 
0318:  CLRF   39
....................             } 
....................          } 
....................           
....................          if (filter_bt_state(input_state(S2), 1)) { 
0319:  MOVLW  00
031A:  BTFSC  06.1
031B:  MOVLW  01
031C:  MOVWF  40
031D:  MOVWF  41
031E:  MOVLW  01
031F:  MOVWF  42
0320:  CALL   1FB
0321:  MOVF   21,F
0322:  BTFSC  03.2
0323:  GOTO   32F
....................             if (!digitos[1]) { 
0324:  MOVF   3C,F
0325:  BTFSS  03.2
0326:  GOTO   32E
....................                pontos++; 
0327:  INCF   37,F
0328:  BTFSC  03.2
0329:  INCF   38,F
....................                digitos[1] = get_prox_valor_sequencia();  
032A:  CALL   22D
032B:  MOVF   21,W
032C:  MOVWF  3C
....................             } else { 
032D:  GOTO   32F
....................                estado = 0; 
032E:  CLRF   39
....................             } 
....................          } 
....................           
....................          if (filter_bt_state(input_state(S3), 2)) { 
032F:  MOVLW  00
0330:  BTFSC  06.2
0331:  MOVLW  01
0332:  MOVWF  40
0333:  MOVWF  41
0334:  MOVLW  02
0335:  MOVWF  42
0336:  CALL   1FB
0337:  MOVF   21,F
0338:  BTFSC  03.2
0339:  GOTO   345
....................             if (!digitos[2]) { 
033A:  MOVF   3D,F
033B:  BTFSS  03.2
033C:  GOTO   344
....................                pontos++; 
033D:  INCF   37,F
033E:  BTFSC  03.2
033F:  INCF   38,F
....................                digitos[2] = get_prox_valor_sequencia();  
0340:  CALL   22D
0341:  MOVF   21,W
0342:  MOVWF  3D
....................             } else { 
0343:  GOTO   345
....................                estado = 0; 
0344:  CLRF   39
....................             } 
....................          } 
....................           
....................          if (filter_bt_state(input_state(S4), 3)) { 
0345:  MOVLW  00
0346:  BTFSC  06.3
0347:  MOVLW  01
0348:  MOVWF  40
0349:  MOVWF  41
034A:  MOVLW  03
034B:  MOVWF  42
034C:  CALL   1FB
034D:  MOVF   21,F
034E:  BTFSC  03.2
034F:  GOTO   35B
....................             if (!digitos[3]) { 
0350:  MOVF   3E,F
0351:  BTFSS  03.2
0352:  GOTO   35A
....................                pontos++; 
0353:  INCF   37,F
0354:  BTFSC  03.2
0355:  INCF   38,F
....................                digitos[3] = get_prox_valor_sequencia();  
0356:  CALL   22D
0357:  MOVF   21,W
0358:  MOVWF  3E
....................             } else { 
0359:  GOTO   35B
....................                estado = 0; 
035A:  CLRF   39
....................             } 
....................          } 
035B:  GOTO   2F2
....................       } 
035C:  GOTO   280
....................    } 
....................  
.................... } 
....................  
035D:  SLEEP
.................... int8 get_prox_valor_sequencia() { 
....................    i_sequencia_atual++; 
*
022D:  INCF   3F,F
....................    if (i_sequencia_atual >= TAM_SEQUENCIA) { 
022E:  MOVF   3F,W
022F:  SUBLW  13
0230:  BTFSS  03.0
....................       i_sequencia_atual = 0; 
0231:  CLRF   3F
....................    } 
....................     
....................    switch (estado) { 
0232:  MOVLW  01
0233:  SUBWF  39,W
0234:  ADDLW  FC
0235:  BTFSC  03.0
0236:  GOTO   250
0237:  ADDLW  04
0238:  GOTO   251
....................       case 1: 
....................          return sequencia_fase1[i_sequencia_atual];   
0239:  MOVF   3F,W
023A:  CALL   03F
023B:  MOVWF  21
023C:  MOVWF  21
023D:  GOTO   250
....................       break;  
023E:  GOTO   250
....................       case 2: 
....................          return sequencia_fase2[i_sequencia_atual];  
023F:  MOVF   3F,W
0240:  CALL   057
0241:  MOVWF  21
0242:  MOVWF  21
0243:  GOTO   250
....................       break;  
0244:  GOTO   250
....................       case 3: 
....................          return sequencia_fase3[i_sequencia_atual];            
0245:  MOVF   3F,W
0246:  CALL   06F
0247:  MOVWF  21
0248:  MOVWF  21
0249:  GOTO   250
....................       break;  
024A:  GOTO   250
....................       case 4: 
....................          return sequencia_fase4[i_sequencia_atual];            
024B:  MOVF   3F,W
024C:  CALL   087
024D:  MOVWF  21
024E:  MOVWF  21
024F:  GOTO   250
....................       break;           
....................    } 
0250:  RETURN
.................... } 
....................  
.................... void atualiza_sequenciaf() { 
....................    for (int8 i = 0; i < 4; i++) { 
*
01B4:  CLRF   40
01B5:  MOVF   40,W
01B6:  SUBLW  03
01B7:  BTFSS  03.0
01B8:  GOTO   1C5
....................       if (!digitos[i]) { 
01B9:  MOVLW  3B
01BA:  ADDWF  40,W
01BB:  MOVWF  04
01BC:  MOVF   00,F
01BD:  BTFSC  03.2
....................          estado = 0; // falha 
01BE:  CLRF   39
....................       } 
....................       digitos[i]--; 
01BF:  MOVLW  3B
01C0:  ADDWF  40,W
01C1:  MOVWF  04
01C2:  DECF   00,F
01C3:  INCF   40,F
01C4:  GOTO   1B5
....................    } 
01C5:  BCF    0A.3
01C6:  GOTO   304 (RETURN)
.................... } 
....................  
.................... void inicializa_fase() { 
....................     switch (estado) { 
*
0152:  MOVLW  01
0153:  SUBWF  39,W
0154:  ADDLW  FC
0155:  BTFSC  03.0
0156:  GOTO   1A2
0157:  ADDLW  04
0158:  GOTO   1AC
....................       case 1: 
....................          for (int8 i = 0; i < 4; i++) { 
0159:  CLRF   40
015A:  MOVF   40,W
015B:  SUBLW  03
015C:  BTFSS  03.0
015D:  GOTO   167
....................             digitos[i] = sequencia_fase1[i]; 
015E:  MOVLW  3B
015F:  ADDWF  40,W
0160:  MOVWF  04
0161:  MOVF   40,W
0162:  CALL   03F
0163:  MOVWF  21
0164:  MOVWF  00
0165:  INCF   40,F
0166:  GOTO   15A
....................          }    
....................          v_cont_sequencia = V_CONT_SEQUENCIA_FASE1; 
0167:  MOVLW  01
0168:  MOVWF  2D
0169:  MOVLW  4D
016A:  MOVWF  2C
....................       break;  
016B:  GOTO   1A2
....................       case 2: 
....................          for (int8 i = 0; i < 4; i++) { 
016C:  CLRF   41
016D:  MOVF   41,W
016E:  SUBLW  03
016F:  BTFSS  03.0
0170:  GOTO   17A
....................             digitos[i] = sequencia_fase2[i]; 
0171:  MOVLW  3B
0172:  ADDWF  41,W
0173:  MOVWF  04
0174:  MOVF   41,W
0175:  CALL   057
0176:  MOVWF  21
0177:  MOVWF  00
0178:  INCF   41,F
0179:  GOTO   16D
....................          }    
....................          v_cont_sequencia = V_CONT_SEQUENCIA_FASE2; 
017A:  MOVLW  01
017B:  MOVWF  2D
017C:  MOVLW  0E
017D:  MOVWF  2C
....................       break;  
017E:  GOTO   1A2
....................       case 3: 
....................          for (int8 i = 0; i < 4; i++) { 
017F:  CLRF   42
0180:  MOVF   42,W
0181:  SUBLW  03
0182:  BTFSS  03.0
0183:  GOTO   18D
....................             digitos[i] = sequencia_fase3[i]; 
0184:  MOVLW  3B
0185:  ADDWF  42,W
0186:  MOVWF  04
0187:  MOVF   42,W
0188:  CALL   06F
0189:  MOVWF  21
018A:  MOVWF  00
018B:  INCF   42,F
018C:  GOTO   180
....................          }    
....................          v_cont_sequencia = V_CONT_SEQUENCIA_FASE3;             
018D:  CLRF   2D
018E:  MOVLW  C8
018F:  MOVWF  2C
....................       break;  
0190:  GOTO   1A2
....................       case 4: 
....................          for (int8 i = 0; i < 4; i++) { 
0191:  CLRF   43
0192:  MOVF   43,W
0193:  SUBLW  03
0194:  BTFSS  03.0
0195:  GOTO   19F
....................             digitos[i] = sequencia_fase4[i]; 
0196:  MOVLW  3B
0197:  ADDWF  43,W
0198:  MOVWF  04
0199:  MOVF   43,W
019A:  CALL   087
019B:  MOVWF  21
019C:  MOVWF  00
019D:  INCF   43,F
019E:  GOTO   192
....................          }    
....................          v_cont_sequencia = V_CONT_SEQUENCIA_FASE4;             
019F:  CLRF   2D
01A0:  MOVLW  96
01A1:  MOVWF  2C
....................       break;           
....................    } 
....................     
....................    cont_sequencia = v_cont_sequencia; 
01A2:  MOVF   2D,W
01A3:  MOVWF  36
01A4:  MOVF   2C,W
01A5:  MOVWF  35
....................    atualiza_sequencia = 0; 
01A6:  BCF    34.1
....................    contador_display = V_CONTADOR_DISPLAY; 
01A7:  MOVLW  01
01A8:  MOVWF  33
....................    atualiza_display = 1; 
01A9:  BSF    34.0
01AA:  BCF    0A.3
01AB:  GOTO   2F0 (RETURN)
.................... } 
....................  
.................... void escolha_fase() { 
....................    if (!input_state(S1)) { 
*
0138:  BTFSC  06.0
0139:  GOTO   13E
....................       while(!input_state(S1)) { 
013A:  BTFSS  06.0
013B:  GOTO   13A
....................          // 
....................       } 
....................       estado = 1; 
013C:  MOVLW  01
013D:  MOVWF  39
....................    } 
....................     
....................    if (!input_state(S2)) { 
013E:  BTFSC  06.1
013F:  GOTO   144
....................       while(!input_state(S2)) { 
0140:  BTFSS  06.1
0141:  GOTO   140
....................          // 
....................       }    
....................       estado = 2; 
0142:  MOVLW  02
0143:  MOVWF  39
....................    } 
....................    if (!input_state(S3)) { 
0144:  BTFSC  06.2
0145:  GOTO   14A
....................       while(!input_state(S3)) { 
0146:  BTFSS  06.2
0147:  GOTO   146
....................          // 
....................       }    
....................       estado = 3; 
0148:  MOVLW  03
0149:  MOVWF  39
....................    } 
....................    if (!input_state(S4)) { 
014A:  BTFSC  06.3
014B:  GOTO   150
....................       while(!input_state(S4)) { 
014C:  BTFSS  06.3
014D:  GOTO   14C
....................          // 
....................       }    
....................       estado = 4; 
014E:  MOVLW  04
014F:  MOVWF  39
....................    } 
0150:  BCF    0A.3
0151:  GOTO   2EB (RETURN)
.................... } 
....................  
.................... int1 filter_bt_state(int1 state, int8 i) { 
....................     if (state) { 
*
01FB:  MOVF   41,F
01FC:  BTFSC  03.2
01FD:  GOTO   20A
....................       filtro[i] = V_FILTRO; 
01FE:  MOVLW  2E
01FF:  ADDWF  42,W
0200:  MOVWF  04
0201:  MOVLW  64
0202:  MOVWF  00
....................       lido[i] = 0;  
0203:  MOVF   42,W
0204:  MOVWF  43
0205:  CLRF   44
0206:  MOVLW  32
0207:  MOVWF  45
0208:  CALL   1C7
....................    } else if (!lido[i]) { 
0209:  GOTO   22A
020A:  MOVF   42,W
020B:  MOVWF  43
020C:  MOVLW  32
020D:  MOVWF  44
020E:  GOTO   1E4
020F:  BTFSC  21.0
0210:  GOTO   22A
....................       filtro[i]--; 
0211:  MOVLW  2E
0212:  ADDWF  42,W
0213:  MOVWF  04
0214:  DECF   00,F
....................       if (!filtro[i]) { 
0215:  MOVLW  2E
0216:  ADDWF  42,W
0217:  MOVWF  04
0218:  MOVF   00,F
0219:  BTFSS  03.2
021A:  GOTO   22A
....................          filtro[i] = V_FILTRO; 
021B:  MOVLW  2E
021C:  ADDWF  42,W
021D:  MOVWF  04
021E:  MOVLW  64
021F:  MOVWF  00
....................          lido[i] = 1; 
0220:  MOVF   42,W
0221:  MOVWF  43
0222:  MOVLW  01
0223:  MOVWF  44
0224:  MOVLW  32
0225:  MOVWF  45
0226:  CALL   1C7
....................          return 1; 
0227:  MOVLW  01
0228:  MOVWF  21
0229:  GOTO   22C
....................       }      
....................    } 
....................     
....................    return 0; 
022A:  MOVLW  00
022B:  MOVWF  21
022C:  RETURN
.................... } 
....................  
.................... void atualiza_displayf() { 
....................    switch (d_index) { 
*
00F2:  MOVF   3A,W
00F3:  ADDLW  FC
00F4:  BTFSC  03.0
00F5:  GOTO   11F
00F6:  ADDLW  04
00F7:  GOTO   130
....................       case 0: 
....................          // ativa unidade 
....................          output_low(DM); 
00F8:  MOVLW  0F
00F9:  BSF    03.5
00FA:  MOVWF  06
00FB:  BCF    03.5
00FC:  BCF    06.4
....................          output_high(DU); 
00FD:  BSF    03.5
00FE:  MOVWF  06
00FF:  BCF    03.5
0100:  BSF    06.7
....................       break;  
0101:  GOTO   11F
....................        case 1: 
....................          // ativa dezena 
....................          output_low(DU); 
0102:  MOVLW  0F
0103:  BSF    03.5
0104:  MOVWF  06
0105:  BCF    03.5
0106:  BCF    06.7
....................          output_high(DD); 
0107:  BSF    03.5
0108:  MOVWF  06
0109:  BCF    03.5
010A:  BSF    06.6
....................       break;  
010B:  GOTO   11F
....................       case 2: 
....................          // ativa centena 
....................          output_low(DD); 
010C:  MOVLW  0F
010D:  BSF    03.5
010E:  MOVWF  06
010F:  BCF    03.5
0110:  BCF    06.6
....................          output_high(DC); 
0111:  BSF    03.5
0112:  MOVWF  06
0113:  BCF    03.5
0114:  BSF    06.5
....................       break;  
0115:  GOTO   11F
....................       case 3: 
....................          // ativa milhar 
....................          output_low(DC); 
0116:  MOVLW  0F
0117:  BSF    03.5
0118:  MOVWF  06
0119:  BCF    03.5
011A:  BCF    06.5
....................          output_high(DM); 
011B:  BSF    03.5
011C:  MOVWF  06
011D:  BCF    03.5
011E:  BSF    06.4
....................       break;  
....................    } 
....................     
....................    output_d(display_numbers[digitos[d_index]]); 
011F:  MOVLW  3B
0120:  ADDWF  3A,W
0121:  MOVWF  04
0122:  MOVF   00,W
0123:  CALL   031
0124:  MOVWF  40
0125:  BSF    03.5
0126:  CLRF   08
0127:  BCF    03.5
0128:  MOVF   40,W
0129:  MOVWF  08
....................     
....................    d_index++; 
012A:  INCF   3A,F
....................    if (d_index >= 4) { 
012B:  MOVF   3A,W
012C:  SUBLW  03
012D:  BTFSS  03.0
....................       d_index = 0; 
012E:  CLRF   3A
....................    } 
012F:  RETURN
.................... } 
....................  
.................... //!void atualiza_displayf() { 
.................... //!   switch (d_index) { 
.................... //!      case 0: 
.................... //!         // ativa unidade 
.................... //!         output_high(DM); 
.................... //!         output_low(DU); 
.................... //!      break;  
.................... //!       case 1: 
.................... //!         // ativa dezena 
.................... //!         output_high(DU); 
.................... //!         output_low(DD); 
.................... //!      break;  
.................... //!      case 2: 
.................... //!         // ativa centena 
.................... //!         output_high(DD); 
.................... //!         output_low(DC); 
.................... //!      break;  
.................... //!      case 3: 
.................... //!         // ativa milhar 
.................... //!         output_high(DC); 
.................... //!         output_low(DM); 
.................... //!      break;  
.................... //!   } 
.................... //!    
.................... //!   output_d(display_numbers[digitos[d_index]]); 
.................... //!    
.................... //!   d_index++; 
.................... //!   if (d_index >= 4) { 
.................... //!      d_index = 0; 
.................... //!   } 
.................... //!} 
.................... //! 

Configuration Fuses:
   Word  1: 3F71   XT NOWDT PUT BROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
